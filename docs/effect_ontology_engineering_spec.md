# Engineering Specification: Topological Ontology Folding

**Version:** 1.0
**Target System:** `@effect-ontology/core`
**Mathematical Foundation:** Graph Theory, Category Theory (F-Algebras)

---

## 1. Abstract

This specification defines the algorithm for transforming a Directed Acyclic Graph (DAG) representing an Ontology into a `StructuredPrompt` via a **Topological Catamorphism**.

We define the Ontology as a dependency graph $G$ where edges represent structural composition (specifically `Child -> Parent`). The Prompt Generation is defined as a fold over this graph using a specific Algebra, guaranteed to process dependencies (subclasses) before dependents (superclasses) to construct a coherent, hierarchical context.

## 2. Formal Definitions

### 2.1 The Structure (Graph)

Let $G = (V, E)$ be a Directed Graph where:

- $V$ is the set of **ClassNodes** (identified by IRI).
- $E \subseteq V \times V$ is the set of edges.
- **Edge Semantics:** An edge $(u, v) \in E$ exists if and only if $u$ is a direct subclass of $v$ ($u \sqsubseteq v$).
- **Dependency Flow:** $u \to v$ implies $v$ "consumes" $u$. The definition of the Parent class aggregates the definitions of its Children.
- **Constraint:** $G$ must be Acyclic ($DAG$). Cyclic inheritance is invalid in OWL and fatal for this algorithm.

### 2.2 The Context (Data)

Let $\Gamma: V \to D$ be a mapping function where $D$ is the domain of node data (Labels, Properties, Comments).

- $D$ is isomorphic to the `ClassNode` type.
- Properties are values attached to nodes in $D$, not separate nodes in $G$.

### 2.3 The Result Monoid

Let $\mathcal{M} = (S, \oplus, e)$ be a Monoid where:

- $S$ is the set of `StructuredPrompt` objects.
- $\oplus$ (Combine) is the component-wise concatenation of prompt sections (System, User, Examples).
- $e$ (Identity) is the empty prompt.

### 2.4 The Algebra

Let $\alpha$ be the **Prompt Algebra**, a function:

$$
\alpha: D \times List\langle S \rangle \to S
$$

- Input 1 ($D$): The data of the current node.
- Input 2 ($List\langle S \rangle$): The ordered list of prompts generated by the node's dependencies (children).
- Output ($S$): The resulting prompt for the current node.

---

## 3. The Algorithm: "Push-Based Topological Fold"

Because `Effect.Graph` is implemented as an adjacency list optimized for outgoing edges, and our topological sort yields $u$ before $v$ for $u \to v$, we utilize a **Push-Based Accumulation** strategy.

### 3.1 State Definitions

- $\sigma$: The topological sorting of $V$. Sequence of nodes $[v_1, v_2, ..., v_n]$.
- $Results$: A Map $V \to S$ storing the final computed prompt for each node.
- $Accumulator$: A Map $V \to List\langle S \rangle$ storing the results _pushed_ from children to parents.

### 3.2 Execution Logic

$$
\begin{aligned}
& \textbf{Initialize:} \\
& \quad Accumulator(v) \leftarrow [] \quad \forall v \in V \\
& \quad \sigma \leftarrow \text{Graph.topologicalSort}(G) \\
& \\
& \textbf{Iterate } u \in \sigma: \\
& \quad 1. \text{ Retrieve Inputs:} \\
& \quad \quad \text{children\_results} \leftarrow Accumulator(u) \\
& \quad \quad \text{node\_data} \leftarrow \Gamma(u) \\
& \\
& \quad 2. \text{ Apply Algebra:} \\
& \quad \quad \text{result}_u \leftarrow \alpha(\text{node\_data}, \text{children\_results}) \\
& \quad \quad Results(u) \leftarrow \text{result}_u \\
& \\
& \quad 3. \text{ Push to Dependents:} \\
& \quad \quad \text{parents} \leftarrow \text{Graph.neighbors}(G, u) \quad // \text{Nodes } v \text{ s.t. } u \to v \\
& \quad \quad \textbf{For each } v \in \text{parents}: \\
& \quad \quad \quad \text{Append } \text{result}_u \text{ to } Accumulator(v) \\
& \\
& \textbf{Return } Results
\end{aligned}
$$

---

## 4. Implementation Specification (Effect Engineers)

### 4.1 Type Signatures

The Solver must adhere strictly to this signature to maintain referential transparency and error tracking.

```typescript
/**
 * Solves the Graph Catamorphism.
 *
 * @param graph - The dependency graph (Child -> Parent).
 * @param context - The lookup context for node data.
 * @param algebra - The logic to combine a Node and its Children's results.
 * @returns A Map of NodeId -> Result, or Error if cyclic/missing data.
 */
export declare const solveGraph: <R>(
  graph: Graph.Graph<NodeId, unknown>,
  context: OntologyContext,
  algebra: GraphAlgebra<R>
) => Effect.Effect<HashMap.HashMap<NodeId, R>, Error>
```

### 4.2 Performance Constraints

1.  **Time Complexity:** $O(V + E)$.
    - Topological Sort: $O(V + E)$.
    - Fold Loop: Visits each node once ($V$).
    - Push Step: Visits each edge once ($E$).
2.  **Space Complexity:** $O(V \times \text{size}(R))$.
    - We must store results for all nodes to support random access or final aggregation.

### 4.3 Universal Properties (Global Context)

Properties without domains (e.g., Dublin Core) exist **outside** $G$. They form a "Global Environment".

- They should **not** be processed by the Graph Solver.
- They should be processed by a separate function `processUniversalProperties` in the Algebra.
- **Composition:** The final system prompt $P_{final}$ is:
  $$ P*{final} = P*{universal} \oplus \left( \bigoplus\_{v \in \text{Roots}(G)} Results(v) \right) $$
  _(Note: In a disjoint graph, we must collect results from all maximal elements, or simply combine all node results depending on the desired output verbosity)._

### 4.4 Verification Requirements (Tests)

1.  **Topology Law:** For any edge $A \to B$ (A is child of B), `solveGraph` **MUST** compute $A$ before $B$, and $B$'s algebra execution must receive $A$'s result in its input list.
2.  **Completeness:** Every node in $V$ must appear in the final $Results$ map.
3.  **Isolation:** If the graph contains two disconnected components (islands), they must be processed independently but correctly within the same pass.
